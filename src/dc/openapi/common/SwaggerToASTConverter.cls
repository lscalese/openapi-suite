/// This class transforms the OpenAPI Specification (OAS) to AST
Class dc.openapi.common.SwaggerToASTConverter Extends %RegisteredObject
{

Property OAS As %DynamicObject;

Property DocumentCollection As dc.openapi.common.SwaggerDocumentCollection [ InitialExpression = {##class(dc.openapi.common.SwaggerDocumentCollection).%New()} ];

Property AST As dc.openapi.common.ast.OAS;

Property Qualifiers As %String;

Property UseAI As %Boolean [ InitialExpression = 1 ];

Method Transform() As %Status
{
    Set sc = $$$OK

    Set ..OAS = ..DocumentCollection.GetMainDocument()
    ;Set ..AST.OpenAPI = ..OAS.openapi
    Set ..AST = ##class(dc.openapi.common.ast.OAS).%New()
    Do ..Info()
    Do ..Servers()
    Do ..Paths()
    Do ..Models()

    If ..UseAI {
        ;Do ..AIImprovement()
        ;Do ..GenerateOperationIdByAI()
    }

    Return sc
}

Method AIImprovement()
{
    Do ..AST.%JSONExportToString(.astJSON)

    Set prompt = "# Context"_$c(13,10)
                 _"You are analyzing an AST (Abstract Syntax Tree) generated from OpenAPI/Swagger specifications."_$c(13,10)
                 _"Model names in this AST contain package names followed by class names."_$c(13,10,13,10)
                 _"# Task"_$c(13,10)
                 _"Identify class names that appear auto-generated (long names with numbers, cryptic identifiers, etc.) and suggest more appropriate names that:"_$c(13,10)
                 _"- Are descriptive of the model's purpose"_$c(13,10)
                 _"- Follow PascalCase naming conventions"_$c(13,10)
                 _"- Are concise but meaningful"_$c(13,10)
                 _"- IMPORTANT: Keep the package name unchanged, only modify the class name portion"_$c(13,10,13,10)
                 _"# Examples"_$c(13,10)
                 _"- 'mypackage.SchemaResponse12345Object' → 'mypackage.ApiResponse'"_$c(13,10)
                 _"- 'mypackage.TempUserData2' → 'mypackage.UserProfile'"_$c(13,10,13,10)
                 _"# Input AST JSON"_$c(13,10)
                 _"```json"_$c(13,10)
                 _astJSON
                 _$c(13,10)_"```"_$c(13,10,13,10)
                 _"# Response Format"_$c(13,10)
                 _"Return a JSON object with keys being the original full names (including package) and values being the full proposed names (with same package):"_$c(13,10)
                 _"```json"_$c(13,10)
                 _"{"_$c(13,10)
                 _"  ""package.AutoGeneratedName"": ""package.ImprovedName"","_$c(13,10)
                 _"  ""package.AnotherAutoGenName"": ""package.BetterName"""_$c(13,10)
                 _"}"_$c(13,10)
                 _"```"_$c(13,10)
                 _"Only include classes that need renaming. If no auto-generated names are found, return an empty JSON object {}."
    
    Do ##class(dc.openapi.common.AITools).Ask(prompt)
    Write !
}

Method GenerateOperationIdByAI()
{
    Do ..AST.%JSONExportToString(.astJSON)
    Set prompt = "# Context"_$c(13,10)
                 _"You are analyzing an AST (Abstract Syntax Tree) generated from OpenAPI/Swagger specifications."_$c(13,10)
                 _"In OpenAPI, each API endpoint should have a unique operationId that:"_$c(13,10)
                 _"- Identifies the operation"_$c(13,10)
                 _"- Is used to generate method names in client SDKs"_$c(13,10)
                 _"- Should clearly describe what the operation does"_$c(13,10,13,10)
                 _"# Task"_$c(13,10)
                 _"Analyze the AST and identify API endpoints (in the 'paths' section) that have an empty OperationId properties."_$c(13,10)
                 _"For each endpoint with a missing operationId, generate an appropriate operationId that:"_$c(13,10)
                 _"- Is descriptive of the operation's purpose (based on path, HTTP verb, and description)"_$c(13,10)
                 _"- Follows camelCase naming conventions (starts with lowercase letter)"_$c(13,10)
                 _"- Is concise but meaningful"_$c(13,10)
                 _"- Avoids generic names like 'getData' or 'updateItem'"_$c(13,10)
                 _"- Is unique within the API"_$c(13,10,13,10)
                 _"# Examples"_$c(13,10)
                 _"- GET /users → 'getUsers' or 'listUsers'"_$c(13,10)
                 _"- POST /users → 'createUser'"_$c(13,10)
                 _"- GET /users/{id} → 'getUserById'"_$c(13,10)
                 _"- PUT /products/{productId} → 'updateProduct'"_$c(13,10)
                 _"- DELETE /orders/{orderId} → 'deleteOrder'"_$c(13,10,13,10)
                 _"# Input AST JSON"_$c(13,10)
                 _"```json"_$c(13,10)
                 _astJSON
                 _$c(13,10)_"```"_$c(13,10,13,10)
                 _"# Response Format"_$c(13,10)
                 _"Return a JSON object with keys being the endpoint path + HTTP method and values being the suggested operationId:"_$c(13,10)
                 _"```json"_$c(13,10)
                 _"{"_$c(13,10)
                 _"  ""GET /users"": ""listUsers"","_$c(13,10)
                 _"  ""POST /items"": ""createItem"","_$c(13,10)
                 _"  ""PUT /orders/{id}"": ""updateOrder"""_$c(13,10)
                 _"}"_$c(13,10)
                 _"```"_$c(13,10)
                 _"Only include paths that need an operationId. If all paths already have operationIds, return an empty JSON object {}."
    
    Do ##class(dc.openapi.common.AITools).Ask(prompt)
}

Method Info() As %Status
{
    Set (..AST.Info, info) = ##class(dc.openapi.common.ast.Info).%New()
    
    If '$IsObject(..OAS.info) {
        Return $$$OK
    }

    Set info.Title = ..OAS.info.title
    Set info.Version = ..OAS.info.version
    Set info.Description = ..OAS.info.description
    Set info.TermsOfService = ..OAS.info.termsOfService

    Return $$$OK
}

Method Models() As %Status
{
    Set sc = $$$OK

    If '$IsObject(..OAS.components) {
        Return sc
    }

    If '$IsObject(..OAS.components.schemas) {
        Return sc
    }

    #dim iterator As %Iterator.AbstractIterator
    Set iterator = ..OAS.components.schemas.%GetIterator()
    While iterator.%GetNext(.key, .schema, .type) {
        
        If '$IsObject(schema) Continue
        
        Set model = ..GetModel(..OAS.components.schemas, key)

        Do:$IsObject(model) ..AST.Models.Insert(model)
    }

    Return sc
}

Method GetModel(parentObj As %DynamicObject, modelName As %String) As dc.openapi.common.ast.Model
{
    ; schema is a swagger schema component
    Set schema = parentObj.%Get(modelName)

    If '$IsObject(schema) {
        Return ""
    }

    If schema.type '= "object" && '$IsObject(schema.allOf) && '$IsObject(schema.oneOf) && '$IsObject(schema.anyOf) {
        ; is not an object schema definition
        Return ""
    }

    Set model = ##class(dc.openapi.common.ast.Model).%New()
    Set model.SchemaRef = "#/components/schemas/" _ modelName
    Set model.Name = ..GetClassName(model.SchemaRef)
    
    If schema.%IsDefined("description") {
        Set model.Description = schema.description
    }

    If $IsObject(schema.properties) {
        Set iterator = schema.properties.%GetIterator()
        While iterator.%GetNext(.key, .item, .type) {
            If '$IsObject(item) Continue

            Set modelProperty = ..GetModelProperty(schema.properties, key)
            Do:$IsObject(modelProperty) model.Properties.Insert(modelProperty)
        }
    }
    
    If schema.%IsDefined("allOf") {
        Set iterator = schema.allOf.%GetIterator()
        While iterator.%GetNext(.key, .allOfItem, .type) {
            If '$IsObject(allOfItem) Continue
            If allOfItem."$ref" '= "" {
                ; it's an object reference (flatten spec garantees that)
                Set model.Super = model.Super _ "," _ ..GetClassName(allOfItem."$ref")
            }
            ElseIf allOfItem.%IsDefined("type") {
                Set modelProperty = ..GetModelProperty(schema.allOf, key)
                Set modelProperty.Name = "AllOf" _ allOfItem.type _ key
                Do:$IsObject(modelProperty) model.Properties.Insert(modelProperty)
            }
        }
    }

    If schema.%IsDefined("oneOf") {
        Set iterator = schema.oneOf.%GetIterator()
        While iterator.%GetNext(.key, .oneOfItem, .type) {
            If '$IsObject(oneOfItem) Continue

            Set modelProperty = ..GetModelProperty(schema.oneOf, key)
            Set modelProperty.Name = "OneOf" _ oneOfItem.type _ key
            Do:$IsObject(modelProperty) model.Properties.Insert(modelProperty)
        }
    }

    If schema.%IsDefined("anyOf") {
        Set iterator = schema.anyOf.%GetIterator()
        While iterator.%GetNext(.key, .anyOfItem, .type) {
            If '$IsObject(anyOfItem) Continue

            Set modelProperty = ..GetModelProperty(schema.anyOf, key)
            Set modelProperty.Name = "AnyOf" _ anyOfItem.type _ key
            Do:$IsObject(modelProperty) model.Properties.Insert(modelProperty)
        }
    }

    Return model
}

Method GetModelProperty(parentObj As %DynamicObject, name As %String) As dc.openapi.common.ast.ModelProperty
{
    Set schema = parentObj.%Get(name)

    Set common = schema

    Set modelProperty = ##class(dc.openapi.common.ast.ModelProperty).%New()
    Set modelProperty.Name = ..GetPropertyNameByRef(name)
    Set modelProperty.pJSONFieldName = name

    If schema."$ref" '= "" {
        Set modelProperty.Type = ..GetClassName(schema."$ref")
    } 
    ElseIf schema.type = "array" {
        Set modelProperty.Collection = "list"
        If $IsObject(schema.items) {
            If schema.items."$ref" '= "" {
                Set modelProperty.Type = ..GetClassName(schema.items."$ref")
            }
            Else {
                Set modelProperty.Type = ..GetObjectScriptType(schema.items.type, schema.items.format)
                Set common = schema.items
            }
        }
    }
    Else {
        Set modelProperty.Type = ..GetObjectScriptType(schema.type, schema.format)
    }

    Set:common.%IsDefined("minimum") modelProperty.pMinimum = common.minimum
    Set:common.%IsDefined("maximum") modelProperty.pMaximum = common.maximum
    Set:common.%IsDefined("minLength") modelProperty.pMinLength = common.minLength
    Set:common.%IsDefined("maxLength") modelProperty.pMaxLength = common.maxLength

    If $IsObject(common.enum) {
        Set iterator = common.enum.%GetIterator()
        While iterator.%GetNext(.key, .item, .type) {
            If '$IsObject(item) Continue
            Set modelProperty.pEnum = modelProperty.pEnum _ "," _ item
        }
    }

    Return modelProperty
}

Method Servers() As %Status
{
    If '$IsObject(..OAS.servers) {
        Return $$$OK
    }

    #dim iterator As %Iterator.AbstractIterator
    Set iterator = ..OAS.servers.%GetIterator()

    While iterator.%GetNext(.key, .item, .type) {
        If '$IsObject(item) {
            Continue
        }

        Set server = ##class(dc.openapi.common.ast.Server).%New()
        Set server.Url = item.url
        Set server.Description = item.description

        Do ..AST.Servers.Insert(server)
    }
}

Method Paths() As %Status
{
    If '$IsObject(..OAS.paths) {
        Return $$$OK
    }

    #dim iterator As %Iterator.AbstractIterator
    Set iterator = ..OAS.paths.%GetIterator()

    While iterator.%GetNext(.key, .item, .type) {
        If '$IsObject(item)  Continue
        
        Do verbs    ; iterate over the verbs
    }

    Return $$$OK

verbs
    For verb = "get", "put", "post", "delete", "options", "head", "patch", "trace" {
        Set verbItem = item.%Get(verb)
        
        If '$IsObject(verbItem) Continue

        Set path = ##class(dc.openapi.common.ast.Path).%New()
        Set path.Path = key
        Set path.Verb = verb
        Set path.OperationId = verbItem.operationId
        Set path.Summary = verbItem.summary
        Set path.Description = verbItem.description
        
        Do parameters   ; now iterate over the parameters and requestBody
        Do requestBody  ; now iterate over the requestBody
        Do responses
        Do ..AST.Paths.Insert(path)
    }

    Quit 1

parameters

    #dim paramIterator As %Iterator.AbstractIterator

    If '$IsObject(verbItem.parameters) {
        Quit
    }

    Set paramIterator = verbItem.parameters.%GetIterator()
    While paramIterator.%GetNext(.paramKey, .paramItem, .paramType) {
        If '$IsObject(paramItem) {
            Continue
        }

        Set parameter = ..GetParameter(paramItem)
        Do path.Parameters.Insert(parameter)
        
    }
    Quit 1

requestBody

    If '$IsObject(verbItem.requestBody) Quit 1
    
    Set rBody = verbItem.requestBody
    If rBody."$ref" '= "" {
        Set rBody = ..GetReference(rBody."$ref")
    }

    If '$IsObject(rBody.content) Quit 1
    /// maybe handle here requestBody.$ref if the flatten don't move it

    Set mimeTypeIterator = rBody.content.%GetIterator()
    While mimeTypeIterator.%GetNext(.mimeType, .mimeItem) {
        If '$IsObject(mimeItem) {
            Continue
        }
        

        Set requestBody = ##class(dc.openapi.common.ast.RequestBody).%New()
        Set requestBody.ContentType = mimeType
        Set requestBody.Required = rBody.required
        Set requestBody.Description = rBody.description

        Set modelProperty = ..GetModelProperty(mimeItem, "schema")
        
        Set modelProperty.Name = ..GetPropertyNameByRef(mimeType)
        Set requestBody.ModelProperty = modelProperty

        Do path.RequestBodies.Insert(requestBody)
    }

    Quit 1

responses

    If '$IsObject(verbItem.responses) Quit 1

    Set codeIterator = verbItem.responses.%GetIterator()
    While codeIterator.%GetNext(.code, .responseItem, .type) {
        If '$IsObject(responseItem) {
            Continue
        }

        If responseItem."$ref" '= "" {
            Set ref = ..GetReference(responseItem."$ref", .found)
            If found {
                Set responseItem = ref
            } Else {
                ; not found
            }
        }

        If $IsObject(responseItem.content) {
            Set mimeTypeIterator = responseItem.content.%GetIterator()
            While mimeTypeIterator.%GetNext(.mimeType, .mimeItem) {
                If '$IsObject(mimeItem) {
                    Continue
                }
                Set response = ##class(dc.openapi.common.ast.Response).%New()
                Set response.StatusCode = code
                Set response.Description = responseItem.description
                Set response.ContentType = mimeType
                Set response.Example = $Select($IsObject(mimeItem.example):mimeItem.example.%ToJSON(), 1: mimeItem.examples)
                Set modelProperty = ..GetModelProperty(mimeItem, "schema")
                Set modelProperty.Name = "Content"
                Set response.ModelProperty = modelProperty
                Do path.Responses.Insert(response)
            }
        }
    }

    Quit 1
}

Method GetParameter(paramItem As %DynamicObject) As dc.openapi.common.ast.Parameter
{
    If paramItem."$ref" '= "" {
        Set ref = ..GetReference(paramItem."$ref", .found)
        If found {
            Set paramItem = ref
        } Else {
            ; not found
        }
    }

    Set parameter = ##class(dc.openapi.common.ast.Parameter).%New()
    Set parameter.Name = paramItem.name
    Set parameter.In = paramItem.in
    Set parameter.Required = paramItem.required
    Set parameter.Description = paramItem.description
    Set modelProperty = ..GetModelProperty(paramItem, "schema")
    Set modelProperty.Name = ..GetPropertyNameByRef(paramItem.name)
    Set parameter.ModelProperty = modelProperty
    Return parameter
}

/// Return the class name from a "$ref" components.schemas.
Method GetClassName(ref As %String) As %String
{
    Set documentReference = ..DocumentCollection.GetItem($Piece(ref, "#", 1))
    Set package = documentReference.GetModelPackage()
    Set className = ..ToPascalCase($Piece(ref, "/", *))
    Return $$$LOWER(package) _ "." _ className
}

Method GetPropertyNameByRef(ref As %String) As %String
{
    Return ..ToPascalCase($Piece(ref, "/", *))
}

ClassMethod ToPascalCase(name As %String) As %String
{
    Set name = $Translate(name, " -%@","__")
    Set pascalCase = ""
    Set list = $ListFromString(name, "_"), ptr = 0
    While $ListNext(list, ptr, value) {
        Set pascalCase = pascalCase _ $$$UPPER($Extract(value, 1, 1)) _ $Extract(value, 2, *)
    }
    Return pascalCase
}

Method GetReference(ref As %String, Output found As %Boolean) As %DynamicObject
{
    Set currentDocument = ..OAS, found = $$$YES
    Try {
        Set object = ##class(dc.openapi.common.ReferenceAnalyzer).GetObjectByRef(currentDocument, ref, ..DocumentCollection)
    } Catch ex {
        Set object = ""
        Set found = $$$NO
    }
    Return object
}

ClassMethod GetObjectScriptType(oaType As %DynamicObject, format As %String = "") As %String
{
    Return ##class(dc.openapi.common.Utils).GetObjectScriptType(oaType, format)
}

}
